<?php

/*
 * This file is part of EC-CUBE
 *
 * Copyright(c) EC-CUBE CO.,LTD. All Rights Reserved.
 *
 * http://www.ec-cube.co.jp/
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Eccube\Repository;

use Doctrine\ORM\Query\Expr\Join;
use Eccube\Doctrine\Query\Queries;
use Eccube\Entity\ProductClass;
use Eccube\Util\StringUtil;
use Symfony\Bridge\Doctrine\RegistryInterface;

/**
 * ProductClassRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class ProductClassRepository extends AbstractRepository
{

    /**
     * @var Queries
     */
    protected $queries;
    /**
     * ProductClassRepository constructor.
     *
     * @param RegistryInterface $registry
     * @param Queries $queries
     */
    public function __construct(RegistryInterface $registry, Queries $queries)
    {
        parent::__construct($registry, ProductClass::class);
        $this->queries = $queries;
    }

    public const COLUMNS = [
        'product_id' => 'p.id', 'name' => 'p.name', 'product_code' => 'pc.code', 'status' => 'p.Status'
    ];

    /**
     * get query builder.
     *
     * @param  array $searchData
     *
     * @return \Doctrine\ORM\QueryBuilder
     */
    public function getQueryBuilderBySearchDataForAdmin($searchData)
    {
        $qb = $this->createQueryBuilder('pc')
            ->addSelect('p')
            ->innerJoin('pc.Product', 'p');


        // パンフレットコード
        if (isset($searchData['pamphlet_code']) && StringUtil::isNotBlank($searchData['pamphlet_code'])) {
            $codes = explode(',', $searchData['pamphlet_code']);
            $orX = $qb->expr()->orX();
            foreach ($codes as $code) {
                $likeExpression = $qb->expr()->like('pc.pamphlet_code', $qb->expr()->literal($code . '%'));
                $orX->add($likeExpression);
            }
            $qb->andWhere($orX);
        }

        // 商品コード
        if (isset($searchData['code']) && StringUtil::isNotBlank($searchData['code'])) {
            $qb->andWhere(
                $qb->expr()->like('p.code', $qb->expr()->literal($searchData['code'] . '%'))
            );
        }

        // 商品名
        if (isset($searchData['name']) && StringUtil::isNotBlank($searchData['name'])) {
            $qb->andWhere(
                $qb->expr()->like('p.name', $qb->expr()->literal('%' . $searchData['name'] . '%'))
            );
        }

        // サイトカテゴリ
        if (!empty($searchData['Category']) && $searchData['Category']) {
            $qb->andWhere($qb->expr()->eq('p.Category', $qb->expr()->literal($searchData['Category']->getId())));
        }

        // 仕入先
        if (!empty($searchData['ProductSupplier']) && $searchData['ProductSupplier']) {
            $qb->innerJoin('p.ProductSupplier', 'ps')
                ->andWhere($qb->expr()->eq('ps.id', $qb->expr()->literal($searchData['ProductSupplier']->getId())));
        }

        // まとめ買いグループ
        if (!empty($searchData['BulkBuying']) && $searchData['BulkBuying']) {
            $qb->innerJoin('pc.BulkBuying', 'bb')
                ->andWhere($qb->expr()->eq('bb.id', $qb->expr()->literal($searchData['BulkBuying']->getId())));
        }

        // 状態
        if (isset($searchData['status']) && $searchData['status']) {
            $qb->andWhere($qb->expr()->eq('pc.status', $qb->expr()->literal($searchData['status'])));
        }

        // 温度帯（送料計算用区分）
        if (!empty($searchData['DeliveryCalculation']) && $searchData['DeliveryCalculation']) {
            $qb->andWhere($qb->expr()->eq('p.DeliveryCalculation', $qb->expr()->literal($searchData['DeliveryCalculation']->getId())));
        }

        // 定期購入品区分
        if (!empty($searchData['SubscriptionPurchase']) && $searchData['SubscriptionPurchase']) {
            $qb->andWhere($qb->expr()->eq('pc.SubscriptionPurchase', $qb->expr()->literal($searchData['SubscriptionPurchase']->getId())));
        }

        // アイコン
        if (!empty($searchData['ProductIcon']) && $searchData['ProductIcon']) {
            $qb->andWhere(
                $qb->expr()->orX(
                    $qb->expr()->eq('pc.ProductIcon1', $qb->expr()->literal($searchData['ProductIcon']->getId())),
                    $qb->expr()->eq('pc.ProductIcon2', $qb->expr()->literal($searchData['ProductIcon']->getId())),
                    $qb->expr()->eq('pc.ProductIcon3', $qb->expr()->literal($searchData['ProductIcon']->getId()))
                )
            );
        }

        // 新商品区分
        if (!empty($searchData['NewProductCategory']) && $searchData['NewProductCategory']) {
            $qb->innerJoin('pc.NewProductCategory', 'npc')
                ->andWhere($qb->expr()->eq('npc.id', $qb->expr()->literal($searchData['NewProductCategory']->getId())));
        }

        // 紹介品区分
        if (!empty($searchData['IntroduceGoods']) && $searchData['IntroduceGoods']) {
            $qb->innerJoin('pc.IntroduceGoods', 'ic')
                ->andWhere($qb->expr()->eq('ic.id', $qb->expr()->literal($searchData['IntroduceGoods']->getId())));
        }

        // キーワード
        if (!empty($searchData['keyword']) && $searchData['keyword']) {
            $qb->andWhere($qb->expr()->orX(
                $qb->expr()->like('pc.keyword', $qb->expr()->literal('%' . $searchData['keyword'] . '%')),
            ));
        }

        // 掲載日
        if (!empty($searchData['insert_start_date']) && $searchData['insert_start_date'] && !empty($searchData['insert_end_date']) && $searchData['insert_end_date']) {
            $start = date_format($searchData['insert_start_date'], 'Y-m-d H:i:s');
            $end = date_format($searchData['insert_end_date'], 'Y-m-d H:i:s');

            $orX = $qb->expr()->orX();

            $orX->add($qb->expr()->between('pc.insert_start_date', $qb->expr()->literal($start), $qb->expr()->literal($end)));
            $orX->add($qb->expr()->between('pc.insert_end_date', $qb->expr()->literal($start), $qb->expr()->literal($end)));

            $orX->add($qb->expr()->andX(
                $qb->expr()->lte('pc.insert_start_date', $qb->expr()->literal($start)),
                $qb->expr()->gte('pc.insert_end_date', $qb->expr()->literal($end))
            ));

            $qb->andWhere($orX);
        }

        // 在庫インポートフラグ
        if (!empty($searchData['stock_import_flag']) && $searchData['stock_import_flag']) {
        }

        // 在庫扱いの種別
        if (!empty($searchData['stock_type']) && $searchData['stock_type']) {
        }

        // キャンペーン設定
        if (!empty($searchData['campaign_config']) && $searchData['campaign_config']) {
            $andX = $qb->expr()->andX();
            if ($searchData['campaign_config']) {
                $andX->add($qb->expr()->isNotNull('pc.campaign_start_period'));
                $andX->add($qb->expr()->isNotNull('pc.campaign_end_period'));
                $andX->add($qb->expr()->isNotNull('pc.campaign_point'));
            } else {
                $andX->add($qb->expr()->isNull('pc.campaign_start_period'));
                $andX->add($qb->expr()->isNull('pc.campaign_end_period'));
                $andX->add($qb->expr()->isNull('pc.campaign_point'));
            }
            $qb->andWhere($andX);
        }

        // イベント
        if (!empty($searchData['event']) && $searchData['event']) {
        }

        // タグ名
        if (!empty($searchData['tag_name']) && $searchData['tag_name']) {
        }

        // FromTo検索
        $fromToSearchColumns = [
            // 通常価格
            'price' => [
                'alias' => 'pc',
                'start' => 'price_start',
                'end' => 'price_end'
            ],
            // 割引期間価格
            'discount_period_price' => [
                'alias' => 'pc',
                'start' => 'discount_period_price_start',
                'end' => 'discount_period_price_end'
            ],
            // 購入限定数
            'purchase_limit' => [
                'alias' => 'pc',
                'start' => 'purchase_limit_start',
                'end' => 'purchase_limit_end'
            ],
            // 購入最低数
            'purchase_minimum' => [
                'alias' => 'pc',
                'start' => 'purchase_minimum_start',
                'end' => 'purchase_minimum_end'
            ],
            // 登録日
            'create_date' => [
                'alias' => 'pc',
                'start' => 'create_date_start',
                'end' => 'create_date_end',
                'format' => 'Y-m-d',
            ],
            // 更新日
            'update_date' => [
                'alias' => 'pc',
                'start' => 'update_date_start',
                'end' => 'update_date_end',
                'format' => 'Y-m-d'
            ],
            // 在庫数
            'stock' => [
                'alias' => 'pc',
                'start' => 'stock_start',
                'end' => 'stock_end'
            ],
        ];

        foreach ($fromToSearchColumns as $column => $values) {
            $start = $searchData[$values['start']];
            $end = $searchData[$values['end']];

            // DateTime to String
            if (!empty($values['format'])) {
                if (!empty($searchData[$values['start']]) && $searchData[$values['start']]) {
                    $start = date_format($searchData[$values['start']], $values['format']);
                }
                if (!empty($searchData[$values['end']]) && $searchData[$values['end']]) {
                    $end = date_format($searchData[$values['end']], $values['format']);
                }
            }

            if (!empty($start) && !empty($end) && $start && $end) {
                $qb->andWhere($qb->expr()->between($values['alias'] . '.' . $column, $qb->expr()->literal($start), $qb->expr()->literal($end)));
            } elseif (!empty($start) && $start) {
                $qb->andWhere($qb->expr()->gte($values['alias'] . '.' . $column, $qb->expr()->literal($start)));
            } elseif (!empty($end) && $end) {
                $qb->andWhere($qb->expr()->lte($values['alias'] . '.' . $column, $qb->expr()->literal($end)));
            }
        }

        // Order By
        if (isset($searchData['sortkey']) && !empty($searchData['sortkey'])) {
            $sortOrder = (isset($searchData['sorttype']) && $searchData['sorttype'] == 'a') ? 'ASC' : 'DESC';

            $qb->orderBy(self::COLUMNS[$searchData['sortkey']], $sortOrder);
            $qb->addOrderBy('p.update_date', 'DESC');
            $qb->addOrderBy('p.id', 'DESC');
        } else {
            $qb->orderBy('p.update_date', 'DESC');
            $qb->addOrderBy('p.id', 'DESC');
        }

        return $this->queries->customize(QueryKey::PRODUCT_SEARCH_ADMIN, $qb, $searchData);
    }


    /**
     * get query builder.
     *
     * @param  array $searchData
     *
     * @return \Doctrine\ORM\QueryBuilder
     */
    public function getQueryBuilderBySearchIdForAdmin($searchData)
    {
        $qb = $this->createQueryBuilder('pc');

        // パンフレットコード
        if (isset($searchData['pamphlet_code']) && StringUtil::isNotBlank($searchData['pamphlet_code'])) {
            $codes = explode(',', $searchData['pamphlet_code']);
            $orX = $qb->expr()->orX();
            foreach ($codes as $code) {
                $likeExpression = $qb->expr()->like('pc.pamphlet_code', $qb->expr()->literal($code . '%'));
                $orX->add($likeExpression);
            }
            $qb->andWhere($orX);
        }

        return $this->queries->customize(QueryKey::PRODUCT_SEARCH_ADMIN, $qb, $searchData);
    }
}
