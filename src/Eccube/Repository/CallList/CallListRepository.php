<?php

/*
 * This file is part of EC-CUBE
 *
 * Copyright(c) EC-CUBE CO.,LTD. All Rights Reserved.
 *
 * http://www.ec-cube.co.jp/
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Eccube\Repository\CallList;
use Eccube\Repository\QueryKey;

use Eccube\Doctrine\Query\Queries;
use Customize\Entity\CallList\CallList;
use Customize\Entity\Master\CallListStatus;
use Eccube\Entity\Customer;
use Eccube\Repository\AbstractRepository;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Bridge\Doctrine\RegistryInterface;

/**
 * CallListRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class CallListRepository extends AbstractRepository
{
     /**
     * @var Queries
     */
    protected $queries;

    public function __construct(
        RegistryInterface $registry, 
        Queries $queries
    )
    {
        parent::__construct($registry, CallList::class);
        $this->queries = $queries;
    }

    public function isGeneratedCallListAtToday(Customer $Customer) {
        $qb = $this->createQueryBuilder('cl');
        // 当日移行のDateを取得
        $date = date('Y/m/d 00:00:00');
        $qb->where('cl.Customer = :Customer')
            ->setParameter('Customer', $Customer);
        $qb->andWhere('cl.create_date >= :create_date')
            ->setParameter('create_date', $date);
        $query = $qb->getQuery()->getResult();

        return !empty($query);
    }

    /**
     * 欠席処理
     * @param CallList $callList
     * @return bool
     */
    public function addNonAttendance(CallList $callList) {
        $customer = $callList->getCustomer();
        $noConsecutive = $customer->getNoConsecutiveOrderCount();
        $customer->setNoConsecutiveOrderCount($noConsecutive + 1);

        // Change CallList status
        $callList->setStatusId(CallListStatus::NON_ATTENDANCE_PROCESSED);

        $em = $this->getEntityManager();
        $em->persist($customer);
        $em->persist($callList);
        $em->flush();

        return !empty($query);
    }

    /**
     * メモ更新処理
     * @param Customer $Customer
     * @return bool
     */
    public function updateTimeDesignation(CallList $callList, Request $request) {
        $customer = $callList->getCustomer();

        $customer->setDeliveryPreferredTime($request->request->get('time_zone'));
        $em = $this->getEntityManager();
        $em->persist($customer);
        $em->flush();

        return !empty($query);
    }

    /**
     * メモ更新処理
     * @param Customer $Customer
     * @return bool
     */
    public function updateNote(CallList $callList, Request $request) {
        $customer = $callList->getCustomer();
        $customer->setCallListNote($request->request->get('note'));

        $em = $this->getEntityManager();
        $em->persist($customer);
        $em->flush();

        return !empty($query);
    }

    /**
     * キャンセル処理
     * @param Customer $Customer
     * @return bool
     */
    public function cancel(CallList $callList) {
        $em = $this->getEntityManager();
        // 休憩処理だった場合は元に戻す
        if ($callList->getStatusId() == CallListStatus::NON_ATTENDANCE_PROCESSED) {
            $customer = $callList->getCustomer();
            $customer->setNoConsecutiveOrderCount($customer->getNoConsecutiveOrderCount() - 1);
            $em->persist($customer);
        }

        $callList->setStatusId(CallListStatus::UNPROCESSED);
        $em->persist($callList);
        $em->flush();

        return !empty($query);
    }

    public function getQueryBuilderBySearchData($searchData)
    {

        $qb = $this->createQueryBuilder('p')
            ->addSelect(['c'])
            ->leftJoin('p.Customer', 'cu');

        if (!empty($searchData['name_kana'])) {

            $qb
                ->andWhere('p.id = :customer_id OR CONCAT(cu.name01, cu.name02) LIKE :name')
                ->setParameter('name', '%' . $searchData['name_kana'] . '%');
        }

        return $this->queries->customize(QueryKey::CUSTOMER_SEARCH, $qb, $searchData);
    }
}
